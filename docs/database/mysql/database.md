---
title: 数据库
tags:
  - 数据库
---

## 事物

### 事物的特性

ACID

A：原子性，不可分割，要么都执行，要么都不执行。
C：一致性，事物执行前后的数据状态一致。
I：隔离性，多个事物之间互不干扰。
D：持久性，事物执行完毕后，数据状态会被持久化到数据库中。

### 事物的并发带来的问题

1. 脏读：**读了别人没有提交的数据**

   一个事务读取了另一个事务未提交的修改。如果另一个事务回滚了，读取到的值就是无效的或脏数据。

2. 不可重复读：**多次读取同一个数据发现数据不一致**

   在一个事务内，某一行数据被多次读取，但这些读取操作之间，该行数据可能被其他事务修改了，导致前后读取的数据不一致。

3. 幻读：**两次查询结果发现条数不一致**

   一个事务在多次查询时，发现同一条件下的结果集在两次读取之间增加或减少了行数据，原因是其他事务在此期间插入或删除了行。

4. 丢失更新：**两个事物同时更新同一行数据，导致数据丢失**

   两个事务同时读取同一条记录并进行修改，最后一个事务的更新会覆盖之前事务的修改，导致前一次事务的更新被丢失。

### 隔离级别

四种隔离级别：

1. 读未提交：事务可以读取其他事务未提交的数据，即脏读是允许的。

   脏读 √ 不可重复读 √ 幻读 √

2. 读已提交：事务只能读取已提交的数据，即不能读取其他事务尚未提交的修改。

   脏读 × 不可重复读 √ 幻读 √

3. 可重复读：保证在事务期间，事务对同一条记录的多次读取结果是一致的，即使其他事务在这期间对数据进行了修改。无法避免幻读，即读取的数据内容是一样的，但是数据集数量不一定

   脏读 × 不可重复读 × 幻读 √

4. 可串行化：这是最高的隔离级别。所有事务**按顺序执行**，仿佛事务是一个接一个地串行执行的，完全避免了脏读、不可重复读和幻读。

   脏读 × 不可重复读 × 幻读 ×

### MySQL 的隔离级别

MySQL 默认隔离级别是可重复读，MySQL 通过 MVCC(多版本并发控制)的方式实现的，InnoDB 为每一行数据添加了一个事物 ID，当事物 ID 写入后，如果数据被修改了，版本号就会+1，事物就无法读取更新后的数据了。

## MySQL 的存储引擎

MySQL 中常用的存储引擎有 MyISAM，InnoDB，MEMORY，ARCHIVE，默认存储引擎为 InnoDB。支持 ACID，行锁和外键。

## 数据库的锁 🔒

在多个用户同时操作同一个数据时，可能会出现并发问题，需要对数据进行加锁，保证数据的一致性。

### 悲观锁

每次拿数据的时候都会认为数据会被修改，所以都上锁。

#### 共享锁

S 锁，读锁，用于所有的只读的数据操作。为了保证在读取这一页或者这个表的时候，其他事务不能对这一页或者这张表进行修改。

- 多个事物可以锁同一个共享页
- 任何事物不可修改
- 读取完毕后，S 锁立即释放

#### 排他锁

X 锁，写锁，用于对数据的写操作。

- 只有一个事物可以锁定此页
- 这个事物不解锁，其他事物无法访问
- X 锁到事物结束才释放

### 乐观锁

## 数据库索引

[一个动画搞懂 MySQL 索引原理！](https://www.bilibili.com/video/BV1pJ4m1j7Pm/?spm_id_from=333.337.search-card.all.click&vd_source=ebd98163213e8a772c16f0e50f1d313b)

### Hash 索引

### B Tree

### B+ Tree

### B Tree 与 B+ Tree 的区别

- B 树的叶子节点和非叶子节点都存储数据，时间复杂度为 O(1)到 O(logn)，不稳定，B+Tree 只有叶子节点存储数据，时间复杂度为固定 O(logn)。所以 B+Tree 的非叶子节点中能够存放更多的范围数据，使得数更加的扁平查找更快。查询效率更加稳定。
- B+Tree 的叶子节点使用链表连接，更适合使用范围查找，而 BTree 只能那个中序遍历。

### 哈希索引与 B+ Tree 索引的区别
